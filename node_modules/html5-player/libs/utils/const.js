'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RETRY_TIMES = exports.SHOW_ERROR_MESSAGE_LAZY_TIME = exports.SHOW_LOADING_LAZY_TIME = exports.LIVING_MAXBUFFER_TIME = exports.DEFAULT_PLAYBACKRATES = exports.CONTROLBAR_HIDE_TIME = exports.ASPECT_RATIO = exports.VIDEO_TIMEOUT = exports.DEBUG = exports.MAX_VOLUME = exports.HAVE_ENOUGH_DATA = exports.HAVE_FUTURE_DATA = exports.HAVE_CURRENT_DATA = exports.HAVE_METADATA = exports.HAVE_NOTHING = undefined;

var _storage = require('./storage');

var storage = _interopRequireWildcard(_storage);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

//参考http://www.w3school.com.cn/tags/av_prop_readystate.asp
//没有关于音频/视频是否就绪的信息
var HAVE_NOTHING = exports.HAVE_NOTHING = 0;
//关于音频/视频就绪的元数据
var HAVE_METADATA = exports.HAVE_METADATA = 1;
//关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒
//timeupdate事件中可以处理状态，当做loading
var HAVE_CURRENT_DATA = exports.HAVE_CURRENT_DATA = 2;
//当前及至少下一帧的数据是可用的
var HAVE_FUTURE_DATA = exports.HAVE_FUTURE_DATA = 3;
//可用数据足以开始播放
var HAVE_ENOUGH_DATA = exports.HAVE_ENOUGH_DATA = 4;
//自定义的最大声音值
var MAX_VOLUME = exports.MAX_VOLUME = 100;

var DEBUG = exports.DEBUG = storage.get('debug');
//视频超时，超时后会超时reload，尝试3次后，报错误信息。
var VIDEO_TIMEOUT = exports.VIDEO_TIMEOUT = 1000 * 10;
//默认的播放器纵横比
var ASPECT_RATIO = exports.ASPECT_RATIO = '16:9';
//用户不活跃的时候，controlbar即将消失的时间
var CONTROLBAR_HIDE_TIME = exports.CONTROLBAR_HIDE_TIME = 2000;
var DEFAULT_PLAYBACKRATES = exports.DEFAULT_PLAYBACKRATES = [1, 1.25, 1.5, 1.75, 2];
//直播最大缓存
var LIVING_MAXBUFFER_TIME = exports.LIVING_MAXBUFFER_TIME = 6;
//延时展示loading的时间
var SHOW_LOADING_LAZY_TIME = exports.SHOW_LOADING_LAZY_TIME = 500;
//延时展示错误信息的时间
var SHOW_ERROR_MESSAGE_LAZY_TIME = exports.SHOW_ERROR_MESSAGE_LAZY_TIME = 500;
//尝试重连次数
var RETRY_TIMES = exports.RETRY_TIMES = 5;