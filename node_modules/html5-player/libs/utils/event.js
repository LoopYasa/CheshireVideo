'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

exports.on = on;
exports.once = once;
exports.off = off;
exports.trigger = trigger;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//     Backbone.js 1.1.2

// Backbone.Events
// ---------------

// A module that can be mixed in to *any object* in order to provide it with
// custom events. You may bind with `on` or remove with `off` callback
// functions to an event; `trigger`-ing an event fires all callbacks in
// succession.
//
//     var object = {};
//     Object.assign(object, Backbone.Events);
//     object.on('expand', function(){ alert('expanded'); });
//     object.trigger('expand');
//

var slice = [].slice;

// Bind an event to a `callback` function. Passing `"all"` will bind
// the callback to all events fired.
function on(name, callback, context) {
  if (!eventsApi(this, 'on', name, [callback, context]) || !callback) {
    return this;
  }
  var _events = this._events || (this._events = {});
  var events = _events[name] || (_events[name] = []);
  events.push({ callback: callback, context: context });
  return this;
}

// Bind an event to only be triggered a single time. After the first time
// the callback is invoked, it will be removed.
function once(name, callback, context) {
  if (!eventsApi(this, 'once', name, [callback, context]) || !callback) {
    return this;
  }
  var count = 0;
  var self = this;
  var onceCallback = function onceCallback() {
    if (count++) {
      return;
    }
    self.off(name, onceCallback);
    callback.apply(this, arguments);
  };
  onceCallback._callback = callback;
  return this.on(name, onceCallback, context);
}

// Remove one or many callbacks. If `context` is null, removes all
// callbacks with that function. If `callback` is null, removes all
// callbacks for the event. If `name` is null, removes all bound
// callbacks for all events.
function off(name, callback, context) {
  if (!this._events || !eventsApi(this, 'off', name, [callback, context])) {
    return this;
  }
  if (!name && !callback && !context) {
    delete this._events;
    return this;
  }
  var names = name ? [name] : (0, _keys2.default)(this._events);
  for (var i = 0, l = names.length; i < l; i++) {
    name = names[i];
    var events = this._events[name];
    if (events) {
      var retain = this._events[name] = [];
      if (callback || context) {
        for (var j = 0, k = events.length; j < k; j++) {
          var ev = events[j];
          if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
            retain.push(ev);
          }
        }
      }
      if (!retain.length) {
        delete this._events[name];
      }
    }
  }
  return this;
}

// Trigger one or many events, firing all bound callbacks. Callbacks are
// passed the same arguments as `trigger` is, apart from the event name
// (unless you're listening on `"all"`, which will cause your callback to
// receive the true name of the event as the first argument).
function trigger(name) {
  if (!this._events) {
    return this;
  }
  var args = slice.call(arguments, 1);
  if (!eventsApi(this, 'trigger', name, args)) {
    return this;
  }
  var events = this._events[name];
  var allEvents = this._events.all;
  if (events) {
    triggerEvents(events, args, this);
  }
  if (allEvents) {
    triggerEvents(allEvents, arguments, this);
  }
  return this;
}

// export function triggerSafe(name) {
//   if (!this._events) {
//     return this;
//   }
//   const args = slice.call(arguments, 1);
//   if (!eventsApi(this, 'trigger', name, args)) {
//     return this;
//   }
//   const events = this._events[name];
//   const allEvents = this._events.all;
//   if (events) {
//     triggerEvents(events, args, this, name);
//   }
//   if (allEvents) {
//     triggerEvents(allEvents, arguments, this, name);
//   }
//   return this;
// }

// Regular expression used to split event strings.
var eventSplitter = /\s+/;

// Implement fancy features of the Events API such as multiple event
// names `"change blur"` and jQuery-style event maps `{change: action}`
// in terms of the existing API.
function eventsApi(obj, action, name, rest) {
  if (!name) {
    return true;
  }
  // Handle event maps.
  if ((typeof name === 'undefined' ? 'undefined' : (0, _typeof3.default)(name)) === 'object') {
    for (var key in name) {
      if (Object.prototype.hasOwnProperty.call(name, key)) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
    }
    return false;
  }
  // Handle space separated event names.
  if (eventSplitter.test(name)) {
    var names = name.split(eventSplitter);
    for (var i = 0, l = names.length; i < l; i++) {
      obj[action].apply(obj, [names[i]].concat(rest));
    }
    return false;
  }
  return true;
}

function triggerEvents(events, args, context, catchExceptionsForName) {
  var i = -1;
  var l = events.length;
  while (++i < l) {
    var ev = events[i];
    if (catchExceptionsForName) {
      try {
        ev.callback.apply(ev.context || context, args);
      } catch (e) {
        /* eslint-disable no-console */
        console.error('Error in "' + catchExceptionsForName + '" event handler:', e);
      }
    } else {
      ev.callback.apply(ev.context || context, args);
    }
  }
}

exports.default = {
  on: on,
  once: once,
  off: off,
  trigger: trigger
};