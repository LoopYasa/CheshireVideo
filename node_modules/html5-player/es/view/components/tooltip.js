import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';

var _class, _temp2;

//外部依赖包
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';
import classnames from 'classnames';
import isNumber from 'lodash/isNumber';
//内部依赖包
import addEventListener from '../../utils/dom/addEventListener';
import contains from '../../utils/dom/contains';
import { cloneElement } from '../../utils/util';

var Tooltip = (_temp2 = _class = function (_React$Component) {
  _inherits(Tooltip, _React$Component);

  function Tooltip() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, Tooltip);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Tooltip.__proto__ || _Object$getPrototypeOf(Tooltip)).call.apply(_ref, [this].concat(args))), _this), _this.displayName = 'Tooltip', _this.state = {
      show: false
    }, _this.dispatch = _this.props.dispatch, _this.eventLists = [], _this.onMouseMove = function (e) {
      var childProps = _this.getChildProps();
      childProps.onMouseMove && childProps.onMouseMove(e);
      var _this$props = _this.props,
          onChange = _this$props.onChange,
          propPercent = _this$props.percent,
          defaultPercent = _this$props.defaultPercent;

      if (isNumber(propPercent) || isNumber(defaultPercent)) {
        var position = _this.getMousePosition(e);
        var pixelOffset = _this.calcValueByPos(position);
        var length = _this.getTargetLength();
        var percent = pixelOffset / length;
        _this.percent = percent;
        onChange && onChange(percent);
        if (!isNumber(propPercent)) {
          //否则触发当前组件更新
          _this.setState({ random: Math.random() });
        }
      }
    }, _this.onClick = function (e) {
      var _this$props$trigger = _this.props.trigger,
          trigger = _this$props$trigger === undefined ? 'hover' : _this$props$trigger;

      var childProps = _this.getChildProps();
      childProps.onClick && childProps.onClick(e);
      var show = _this.state.show;

      if (trigger !== 'click') {
        return;
      }
      if (!show) {
        _this.documentClickEvent = addEventListener(_this.moveTargetDOM.ownerDocument, 'mousedown', function (e) {
          if (!contains(_this.moveTargetDOM, e.target)) {
            _this.setState({
              show: false
            });
            _this.documentClickEvent.remove();
          }
        });
      }
      _this.setState({
        show: !show
      });
    }, _this.onMouseOver = function (e) {
      var childProps = _this.getChildProps();
      childProps.onMouseOver && childProps.onMouseOver(e);
      var _this$props$trigger2 = _this.props.trigger,
          trigger = _this$props$trigger2 === undefined ? 'hover' : _this$props$trigger2;

      if (trigger !== 'hover') {
        return;
      }
      //因为react原生的onMouseEnter有bug，所以自己处理
      var parent = e.relatedTarget; //上一响应mouseover/mouseout事件的元素
      while (parent !== e.currentTarget && parent) {
        //假如存在这个元素并且这个元素不等于目标元素（被赋予mouseenter事件的元素）
        try {
          parent = parent.parentNode || parent.parentElement;
        } catch (e) {
          //上一响应的元素开始往上寻找目标元素
          break;
        }
      }
      if (parent !== e.currentTarget) {
        _this.setState({
          show: true
        });
      }
    }, _this.onMouseLeave = function (e) {
      var childProps = _this.getChildProps();
      childProps.onMouseLeave && childProps.onMouseLeave(e);
      var _this$props$trigger3 = _this.props.trigger,
          trigger = _this$props$trigger3 === undefined ? 'hover' : _this$props$trigger3;

      if (trigger !== 'hover') {
        return;
      }
      _this.setState({
        show: false
      });
    }, _this.percent = isNumber(_this.props.defaultPercent) ? _this.props.defaultPercent : null, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(Tooltip, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.moveTargetDOM = ReactDOM.findDOMNode(this.refs.moveTarget);
      //在高德地图中，react jsx绑定事件失效，这种绑定方式没问题。
      this.eventLists.push(addEventListener(this.moveTargetDOM, 'mousemove', this.onMouseMove));
      this.eventLists.push(addEventListener(this.moveTargetDOM, 'mouseover', this.onMouseOver));
      this.eventLists.push(addEventListener(this.moveTargetDOM, 'mouseleave', this.onMouseLeave));
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (isNumber(nextProps.percent)) {
        this.percent = nextProps.percent;
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.documentClickEvent && this.documentClickEvent.remove();
      this.eventLists.forEach(function (v) {
        v.remove();
      });
    }
  }, {
    key: 'getTargetHeight',
    value: function getTargetHeight() {
      var moveTargetDOM = this.moveTargetDOM;
      if (!moveTargetDOM) {
        return 0;
      }
      return moveTargetDOM.clientHeight;
    }
  }, {
    key: 'getTargetLength',
    value: function getTargetLength() {
      var moveTargetDOM = this.moveTargetDOM;
      if (!moveTargetDOM) {
        return 0;
      }
      return moveTargetDOM.clientWidth;
    }
  }, {
    key: 'getTargetStart',
    value: function getTargetStart() {
      var moveTargetDOM = this.moveTargetDOM;
      var rect = moveTargetDOM.getBoundingClientRect();
      if (moveTargetDOM.offsetLeft > rect.left) {
        //浏览器宽度不足，向左滚动，rect.left会是负数
        return moveTargetDOM.offsetLeft;
      }
      return rect.left;
    }
  }, {
    key: 'calcValueByPos',
    value: function calcValueByPos(position) {
      var pixelOffset = position - this.getTargetStart();
      return pixelOffset;
    }
  }, {
    key: 'getMousePosition',
    value: function getMousePosition(e) {
      return e.pageX;
    }
  }, {
    key: 'getContainerStyle',
    value: function getContainerStyle() {
      var _props$toTargetGap = this.props.toTargetGap,
          toTargetGap = _props$toTargetGap === undefined ? 0 : _props$toTargetGap;

      if (!this.refs['tooltip-container']) {
        return {};
      }
      var contentWidth = this.refs['tooltip-container'].clientWidth;
      //const contentHeight = this.refs['tooltip-container'].clientHeight;
      var targetWidth = this.getTargetLength();
      var targetHeight = this.getTargetHeight();
      var contentContainerStyle = {};
      //const playerConainerRect = this.context.playerConainerDOM.getBoundingClientRect();
      //const playerConainerWidth = playerConainerRect.width;
      if (isNumber(this.percent) && targetWidth) {
        var pixelOffset = this.percent * targetWidth;
        if (pixelOffset + contentWidth / 2 > targetWidth) {
          //位置不能超过tooltip的目标元素长度
          contentContainerStyle.left = (targetWidth - contentWidth / 2) / targetWidth * 100 + '%';
        } else if (pixelOffset <= contentWidth / 2) {
          //位置不能小于tooltip的目标元素长度
          contentContainerStyle.left = contentWidth / 2 / targetWidth * 100 + '%';
        } else {
          contentContainerStyle.left = this.percent * 100 + '%';
        }
        contentContainerStyle.transform = 'translate(-50%, 0%)';
      } else {
        contentContainerStyle.left = targetWidth / 2 + 'px';
        contentContainerStyle.transform = 'translate(-50%, 0%)';
      }
      contentContainerStyle.paddingBottom = toTargetGap + 'px';
      contentContainerStyle.bottom = targetHeight + 'px';
      return contentContainerStyle;
    }
  }, {
    key: 'renderTooltipContent',
    value: function renderTooltipContent() {
      var _props = this.props,
          content = _props.content,
          propsShow = _props.show,
          className = _props.className;
      var show = this.state.show;

      if (propsShow) {
        show = propsShow;
      }
      var contentContainerStyle = this.getContainerStyle();
      var tooltipContainer = React.createElement(
        'div',
        {
          key: 'content',
          onClick: function onClick(e) {
            e.stopPropagation();
          },
          ref: 'tooltip-container',
          className: classnames('html5-player-tooltip-content-container', {
            'html5-player-hide': !show,
            'html5-player-show': show
          }, className),
          style: contentContainerStyle
        },
        content
      );

      return tooltipContainer;
    }
  }, {
    key: 'getChildProps',
    value: function getChildProps() {
      var children = this.props.children;
      //preact;

      var childProps = (children[0] || children).attributes;
      if (!childProps) {
        childProps = (children[0] || children).props;
      }
      return childProps;
    }
  }, {
    key: 'render',
    value: function render() {
      var children = this.props.children;

      return cloneElement(children, {
        onClick: this.onClick,
        style: { position: 'relative' },
        ref: 'moveTarget'
      }, this.renderTooltipContent());
    }
  }]);

  return Tooltip;
}(React.Component), _class.propTypes = {
  content: PropTypes.oneOfType([PropTypes.string, PropTypes.bool, PropTypes.number, PropTypes.element]),
  //是否一直显示。
  show: PropTypes.bool,
  //离目标的上下距离
  toTargetGap: PropTypes.number,
  percent: PropTypes.number,
  defaultPercent: PropTypes.number,
  //触发行为，可选 hover/focus/click，默认hover
  trigger: PropTypes.string
}, _temp2);
export { Tooltip as default };