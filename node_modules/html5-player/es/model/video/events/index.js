import _extends from 'babel-runtime/helpers/extends';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import { namespace as readyNamespace } from '../../ready';
import { namespace as videoNamespace } from '../../video';
import { namespace as historyNamespace } from '../../history';
import { HAVE_CURRENT_DATA, HAVE_FUTURE_DATA, HAVE_ENOUGH_DATA, VIDEO_TIMEOUT, LIVING_MAXBUFFER_TIME, RETRY_TIMES } from '../../../utils/const';
import * as logger from '../../../utils/logger';
import { isSafari } from '../../../utils/browser';

import { TIMEOUT_ERROR } from '../../../utils/error-code';
import { isIE } from '../../../utils/browser';
import contains from '../../../utils/dom/contains';

var Events = function () {
  /**
   *
   * @param {object} payload model vidoe/init的payload
   * @param {boolean} isFirstPlay 是否是第一次播放视频
   * @param {object} _state 存放一些状态，reload都不会改变的
   */
  function Events(payload, isFirstPlay, _state) {
    _classCallCheck(this, Events);

    this.api = payload.api;
    this._state = _state;
    this.dispatch = payload.dispatch;
    //是否是第一次播放视频
    this.isFirstPlay = isFirstPlay;
    this.config = payload.config;
    if (!this.api.hlsObj) {
      this.setOriginHlsSubtitle();
    }
    this.loadeddata();
    this.timeupdate();
    this.pause();
    this.error();
    this.ended();
    this.onSpaceAndVieoFocusEvent();
    this.setTimeoutInterval(true);
    logger.info('Listening:', 'listening on h5 video events.');
  }
  /**
   * 定时检查超时问题，视频播放中卡住超过设定时间，属于超时
   * @param {boolean} withoutPlayingState 无playing状态
   */


  _createClass(Events, [{
    key: 'setTimeoutInterval',
    value: function setTimeoutInterval(withoutPlayingState) {
      var _this = this;

      clearInterval(this.timeoutInterval);
      var _config$timeout = this.config.timeout,
          timeout = _config$timeout === undefined ? VIDEO_TIMEOUT : _config$timeout;

      this.timeoutInterval = setInterval(function () {
        //定时查看是否超时
        //404等非200或者不是正确的视频，刚开始会报错，并不会播放，所以刚开始不能被playing拦截
        // console.log(this.api.playing, withoutPlayingState);
        if (_this.api.playing || withoutPlayingState) {
          _this.timeoutAction();
        }
      }, timeout);
    }
  }, {
    key: 'reset',
    value: function reset() {
      this.currentTime = 0;
      clearInterval(this.timeoutInterval);
    }
    //原生浏览器hls

  }, {
    key: 'setOriginHlsSubtitle',
    value: function setOriginHlsSubtitle() {
      var _this2 = this;

      var api = this.api;
      if (this.config.isHls) {
        var textTracks = api.textTracks;
        var clearIntervalObj = void 0;
        clearInterval(clearIntervalObj);
        var tempLength = 0;
        //trackList长度一样后执行次数
        var count = 0;
        clearIntervalObj = setInterval(function () {
          //由于firefox不支持change事件
          if (textTracks.length === 0) {
            return;
          }
          var subtitleLength = 0;
          var subtitleList = [];
          var subtitleId = 0;
          for (var i = 0; i < textTracks.length; i++) {
            if (textTracks[i].kind === 'subtitles') {
              subtitleList.push(_extends({
                id: subtitleId,
                name: textTracks[i].label
              }, textTracks[i]));
              subtitleId++;
              textTracks[i].mode = 'disabled';
              subtitleLength++;
            }
          }
          if (tempLength === subtitleLength) {
            if (count >= 2) {
              //如果两次以上length都没变化就判断为textTrack没变化。
              //这里不排除网络很差的导致加载出问题，但是这种极端情况，不好处理，也没必要处理。
              //因为如果网络都差到连2KB左右的内容都加载不了，也完全播放不了视频了。
              api.off('cuechange'); //防止连续监听事件。
              for (var _i = 0; _i < textTracks.length; _i++) {
                api.on(textTracks[_i], 'cuechange', function (cues) {
                  _this2.dispatch({
                    type: videoNamespace + '/hlsSubtitleCues',
                    payload: cues.target.activeCues
                  });
                });
              }
              _this2.dispatch({
                type: videoNamespace + '/subtitleList',
                payload: {
                  subtitleList: subtitleList,
                  subtitleId: -1
                }
              });
              clearInterval(clearIntervalObj);
            }
            count++;
          }
          tempLength = subtitleLength;
        }, 200);
      }
    }
  }, {
    key: 'loadeddata',
    value: function loadeddata() {
      var _this3 = this;

      var api = this.api;
      var config = this.config;
      var dispatch = this.dispatch;
      var _config = this.config,
          isLiving = _config.isLiving,
          defaultCurrentTime = _config.defaultCurrentTime;

      api.on('loadeddata', function () {
        _this3.isLoadeddata = true;
        //视频载入后重新定时处理超时。
        _this3.setTimeoutInterval();
        //设置重载状态false，这个视事件运行了，视频就可以播放了。
        logger.info('Ready:', 'video is ready to played.');
        api.trigger('ready');
        // 隐藏 controlbar
        _this3.dispatch({
          type: videoNamespace + '/controlbar',
          payload: false,
          delayTime: config.controlbarHideTime,
          onControlbarEnter: false
        });
        //isLiving强制设置为直播状态。safari中flv无法获取直播状态，所以需要设置这个。
        if (!api.living && !config.isLiving && _this3._state.lastCurrentTime) {
          //播放中途出错，重载需要载入上一个播放进度
          api.currentTime = _this3._state.lastCurrentTime;
          _this3._state.lastCurrentTime = 0;
          if (!_this3.isFirstPlay) {
            dispatch({
              type: videoNamespace + '/play'
            });
          } else if (api.autoplay) {
            dispatch({
              type: videoNamespace + '/play'
            });
          }
        } else if (defaultCurrentTime !== undefined) {
          dispatch({
            type: videoNamespace + '/seekingState',
            payload: true
          });
          dispatch({
            type: videoNamespace + '/seeking',
            payload: {
              percent: defaultCurrentTime / api.duration
            }
          });
          dispatch({
            type: videoNamespace + '/seekingState',
            payload: false
          });
        }

        dispatch({
          type: readyNamespace + '/state'
        });
        //兼容edge，用来比较获取loading状态
        _this3.currentTime = api.currentTime;
        //currentTime处理
        dispatch({
          type: videoNamespace + '/time',
          payload: {
            currentTime: api.currentTime,
            duration: api.duration
          }
        });
        dispatch({
          type: videoNamespace + '/living',
          payload: {
            duration: isLiving ? Infinity : api.duration
          }
        });
        dispatch({
          type: videoNamespace + '/loading',
          payload: {
            loading: false
          }
        });
        api.reloading = false;
        _this3._state.retryReloadTime = 0;
      });
    }
  }, {
    key: 'timeoutAction',
    value: function timeoutAction() {
      var api = this.api;
      var locale = api.localization;
      // const { retryTimes = RETRY_TIMES } = this.config;
      // console.log(this.currentTime, api.currentTime, this.api.isError);
      if (this.api.isError || this.api.ended) {
        return;
      }
      if (this.currentTime !== api.currentTime && this.currentTime !== undefined) {
        //视频在播放（视频状态为播放中，但是没有因为网络而卡顿），不处理
        this.currentTime = api.currentTime;
        return;
      }
      api.trigger('error', {
        //基本上trigger都是为了对外提供api，error是个比较特殊的情况，寄对外提供了事件，也对内提供了事件。
        //如果只是对内不对外的话，不可以使用trigger处理事件，所有的都用redux。
        data: {},
        message: locale.timeout,
        type: TIMEOUT_ERROR
      });
    }
  }, {
    key: 'timeupdate',
    value: function timeupdate() {
      var _this4 = this;

      var api = this.api;
      var dispatch = this.dispatch;
      var _config2 = this.config,
          _config2$livingMaxBuf = _config2.livingMaxBuffer,
          livingMaxBuffer = _config2$livingMaxBuf === undefined ? LIVING_MAXBUFFER_TIME : _config2$livingMaxBuf,
          isHls = _config2.isHls;

      api.on('timeupdate', function () {
        //edge播放原生hls时，在这里会不断运行，即使网络断了
        if (api.playing) {
          if (!api.living) {
            //直播不播放状态中不处理loading
            //begin----处理loading状态
            //isIE包括了Edge
            if (_this4.currentTime === api.currentTime && isIE()) {
              if (!api.loading) {
                //需要做判断，要不会被clearTimeout了
                dispatch({
                  type: videoNamespace + '/loading',
                  payload: {
                    loading: true
                  }
                });
              }
            } else if (!api.loading && api.readyState === HAVE_CURRENT_DATA && !api.ended
            //api.eneded解决firefox，结束后readyState=2导致的loading未关闭的问题
            ) {
                if (!api.loading) {
                  dispatch({
                    type: videoNamespace + '/loading',
                    payload: {
                      loading: true
                    }
                  });
                }
              } else if (api.loading && (api.readyState === HAVE_FUTURE_DATA || api.readyState === HAVE_ENOUGH_DATA)) {
              dispatch({
                type: videoNamespace + '/loading',
                payload: {
                  loading: false
                }
              });
            }
            //end----处理loading状态
          } else if (api.loading && _this4.currentTime !== api.currentTime) {
            //直播状态正在播放中如果发现loading，直接隐藏。
            dispatch({
              type: videoNamespace + '/loading',
              payload: {
                loading: false
              }
            });
          }
          //currentTime处理
          if (!api.seekingState) {
            var namespace = videoNamespace;
            if (_this4.config.isHistory) {
              namespace = historyNamespace;
            }
            dispatch({
              type: namespace + '/time',
              payload: {
                currentTime: api.ended ? api.duration : api.currentTime,
                duration: api.duration
              }
            });
          }
          //直播延时变大处理
          //safari原生的hls，在直播延时处理失效，还没有解决办法，不过hls本来的延时就大，影响不大。
          //使用的hls.js和flv.js延时处理是正常的。
          //edge原生的hls的也正常，不过经常会卡，然后就触发了重载，然后就正常了。
          //正常网络下hls处理延时变大会很少的，flv才可能频繁一点，flv的实时性要求高。
          if (api.living && api.buffered.length > 0 && api.currentTime && livingMaxBuffer > 0 && !api.isError) {
            //livingMaxBuffer=0，相当于没设置，最好不要设置为0
            if (isHls) {
              //hls需要的直播需要特殊对待。
              livingMaxBuffer += 15;
            }
            //直播实时处理，让视频接近实时。
            // console.log(api.bufferTime, api.buffered.end(0));
            if (api.bufferTime - api.currentTime > livingMaxBuffer) {
              var reduceBuffer = void 0;
              if (isHls) {
                reduceBuffer = 15;
              } else {
                reduceBuffer = 1;
              }
              //浏览器原生的hls，在直播状态设置currentTime失效。
              api.currentTime = api.bufferTime - reduceBuffer;
              //标记正在减少延时状态
              _this4.reducingDelay = true;
              //同时超时重新计算
              logger.log('Delay Reduce', 'Due to the high delay, there is a need to reduce the delay.');
            }
          }
          if (api.currentTime) {
            //只要在播放，retryReloadTime就要设置为0。
            _this4._state.retryReloadTime = 0;
          }
          if (_this4.currentTime !== api.currentTime) {
            //需要判断currentTime，因为edge的hls视频即使出错停止了，也会运行timeupdate
            _this4.setTimeoutInterval();
          }
          _this4._state.retryReloadTime = 0;
        }
        if (api.isError && _this4.currentTime !== api.currentTime) {
          //需要判断currentTime，因为edge的hls视频即使出错停止了，也会运行timeupdate
          //隐藏错误信息
          dispatch({
            type: videoNamespace + '/errorMessage',
            payload: {
              message: null
            }
          });
        }
        //最后赋值，可以用来判断视频视频卡顿
        _this4.currentTime = api.currentTime;
      });
    }
  }, {
    key: 'pause',
    value: function pause() {
      var api = this.api;
      api.on('pause', function (e) {
        //清理timeupdate中的定时器。
      });
    }
  }, {
    key: 'error',
    value: function error() {
      var _this5 = this;

      var api = this.api;
      var dispatch = this.dispatch;
      var locale = api.localization;
      var _config$retryTimes = this.config.retryTimes,
          retryTimes = _config$retryTimes === undefined ? RETRY_TIMES : _config$retryTimes;

      api.on('error', function (data) {
        if (data && data.nativeEvent || data && data.parser === 'hls.js') {
          // h5 原生报错截止不处理，只做超时处理。
          // hls.js 报错也不做处理
          return;
        }
        var retryReloadTime = _this5._state.retryReloadTime;
        if (retryReloadTime < retryTimes) {
          _this5._state.retryReloadTime++;
          logger.warn('Timeout:', 'try to reload ' + (retryReloadTime + 1) + ' times.');
          dispatch({
            type: videoNamespace + '/reload',
            payload: {
              retryReloadTime: retryReloadTime + 1
            }
          });
        } else {
          logger.error('Timeout:', 'try to reload ' + retryTimes + ' times but video can not be loaded.');
          _this5._state.retryReloadTime = 1;
          _this5.reset();
          //有message和type的是hls.js等事件的错误
          api.isError = true;
          var message = data.message;
          if (!message) {
            logger.error('H5 Video Error:', 'original h5 video error');
          }
          if (!message) {
            message = locale.fileCouldNotPlay;
          }
          if (_this5.config.videoNotSupport) {
            message = locale.videoNotSupport;
          }
          dispatch({
            type: videoNamespace + '/loading',
            payload: {
              message: null,
              retryReloadTime: 1
            }
          });
          dispatch({
            type: videoNamespace + '/errorMessage',
            payload: {
              message: message
            }
          });
          api.detachMedia && api.detachMedia();
        }
      });
    }
  }, {
    key: 'ended',
    value: function ended() {
      var _this6 = this;

      var api = this.api;
      var dispatch = this.dispatch;
      api.on('ended', function () {
        logger.info('Ended:', 'video is ended');
        if (_this6.config.isHistory) {
          _this6.dispatch({
            type: historyNamespace + '/playNextVideo'
          });
        } else {
          if (!api.living && !_this6.config.isLiving) {
            //直播是不会结束的
            //即使监控到end事件也不做处理
            dispatch({
              type: videoNamespace + '/end',
              payload: true
            });
          } else if (!isSafari()) {
            //直播有时候会遇到结束事件，那是因为转发切换触发结束事件
            //safari flv.js直播经常报ended事件。
            //等待两秒重新拉流，因为转发切换可能会有延时，播放链接不是立即就可以播放。
            //真正直播结束的场景，目前不做考虑。
            setTimeout(function () {
              dispatch({
                type: videoNamespace + '/reload'
              });
            }, 2000);
          }
        }
      });
    }
    //键盘空格键和video聚焦事件

  }, {
    key: 'onSpaceAndVieoFocusEvent',
    value: function onSpaceAndVieoFocusEvent() {
      var _this7 = this;

      if (!this.config.spaceAction) {
        return false;
      }
      var api = this.api;
      var dispatch = this.dispatch;
      var keydown = function keydown() {
        _this7.playerKeydownEvent && _this7.playerKeydownEvent.off();
        _this7.playerKeydownEvent = api.on(api.ownerDocument, 'keydown', function (e) {
          if (api.living) {
            return;
          }
          if (e.keyCode === 32) {
            logger.info('Keydown:', 'space key is pressed');
            if (api.playing) {
              dispatch({
                type: videoNamespace + '/pause'
              });
            } else {
              dispatch({
                type: videoNamespace + '/play'
              });
            }
          }
        });
      };
      api.on(api.parentNode, 'mouseenter', function (e) {
        api.trigger('focus', true);
        if (!api.focus) {
          logger.info('Video Focus:', 'video is focused');
        }
        api.focus = true;
        keydown();
      });
      api.on(api.parentNode, 'mouseleave', function (e) {
        //为点击播放器，移出去播放器，算失去聚焦。
        if (!_this7.mousedown) {
          api.focus = false;
          api.trigger('focus', false);
          logger.info('Video Unfocused:', 'video is unfocused');
          _this7.playerKeydownEvent && _this7.playerKeydownEvent.off();
        }
      });
      api.on(api.parentNode, 'mousedown', function (e) {
        _this7.mousedown = true;
        if (!api.focus) {
          api.trigger('focus', true);
          logger.info('Video Focus:', 'video is focused');
        }
        _this7.documentMousedownEvent && _this7.documentMousedownEvent.off();
        _this7.documentMousedownEvent = api.on(api.ownerDocument, 'mousedown', function (e) {
          if (!contains(api.parentNode, e.target)) {
            _this7.mousedown = false;
            api.trigger('focus', false);
            logger.info('Video Unfocused:', 'video is unfocused');
            _this7.documentMousedownEvent.off();
            _this7.playerKeydownEvent.off();
          }
        });
        keydown();
      });
    }
  }]);

  return Events;
}();

export default function () {
  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return new (Function.prototype.bind.apply(Events, [null].concat(params)))();
}