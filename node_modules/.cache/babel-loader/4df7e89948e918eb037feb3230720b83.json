{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _toConsumableArray2 = require(\"babel-runtime/helpers/toConsumableArray\");\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _keys = require(\"babel-runtime/core-js/object/keys\");\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction identify(value) {\n  return value;\n}\n/**\n * reducer 高阶处理函数，接收 reducer 并返回一个新的 reducer\n * 包装每个 reducer，该高阶 reducer 保证只有当 actionType 对应时才调用入参 reducer\n * 与传统的 reducer 不一样在于 传统的 reducer 需要在内部判断 actionType，\n * 而该高阶 reducer 保证了只有当 actionType 正确对应了才执行入参 reducer，\n * 入参 reducer 可以直接对数据进行维护，免去对 actionType 的判断逻辑。\n *\n * @param {any} actionType\n * @param {any} [reducer=identify]\n * @param {any} ctx 执行 reducer 的上下文\n * @returns\n */\n\n\nfunction handleAction(actionType) {\n  var reducer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identify;\n  var ctx = arguments[2];\n  return function (state, action) {\n    var type = action.type;\n\n    if (type && actionType !== type) {\n      return state;\n    }\n\n    return reducer.call(ctx, state, action);\n  };\n}\n/**\n *\n *\n * @param {any} reducers\n * @returns\n */\n\n\nfunction reduceReducers() {\n  for (var _len = arguments.length, reducers = Array(_len), _key = 0; _key < _len; _key++) {\n    reducers[_key] = arguments[_key];\n  }\n  /**\n   *  @param {any} previous state\n   *  @param {any} current action\n   */\n\n\n  return function (previous, current) {\n    return reducers.reduce(\n    /**\n     *\n     *  @param {any} p state\n     *  @param {any} r reducer\n     */\n    function (p, r) {\n      return r(p, current);\n    }, previous);\n  };\n}\n/**\n * 无序链式调用 handlers 中的 reducer ，所有 reducer 维护同一个 state\n *\n * @param {{ actionType:reducer }} handlers\n * @param {any} defaultState\n * @param {any} ctx 执行  handle 的上下文\n * @returns\n */\n\n\nfunction handleActions(handlers, defaultState, ctx) {\n  var reducers = (0, _keys2.default)(handlers).map(function (type) {\n    return handleAction(type, handlers[type], ctx);\n  }); // 将 reducer 包装成调用链，这里有个问题：\n  // 由于这个链式调用并不保障每次 reducers 对 state 进行更新时，链内只有一个 reducer 响应 actionType。\n  // 导致的结果是如果有多个 reducer 对同一 actionType 进行响应的话，无法保证这些 reducers 之间的调用顺序。\n  // 更新：\n  // 这样做的目的是因为，一般对于同一个 actionType 允许有多个 reducer 进行响应，而这些 reducers 每个都负责维护不同的 state 结构，故当多个 reducer 对同一 actionType 进行响应时，reducers 的调用顺序无关紧要。\n\n  var reducer = reduceReducers.apply(undefined, (0, _toConsumableArray3.default)(reducers));\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;\n    var action = arguments[1];\n    return reducer(state, action);\n  };\n}\n\nexports.default = handleActions;","map":{"version":3,"sources":["C:/Users/MaGent/Desktop/video/video/node_modules/redux-saga-model/lib/handleActions.js"],"names":["Object","defineProperty","exports","value","_toConsumableArray2","require","_toConsumableArray3","_interopRequireDefault","_keys","_keys2","obj","__esModule","default","identify","handleAction","actionType","reducer","arguments","length","undefined","ctx","state","action","type","call","reduceReducers","_len","reducers","Array","_key","previous","current","reduce","p","r","handleActions","handlers","defaultState","map","apply"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _toConsumableArray2 = require(\"babel-runtime/helpers/toConsumableArray\");\n\nvar _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);\n\nvar _keys = require(\"babel-runtime/core-js/object/keys\");\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction identify(value) {\n  return value;\n}\n\n/**\n * reducer 高阶处理函数，接收 reducer 并返回一个新的 reducer\n * 包装每个 reducer，该高阶 reducer 保证只有当 actionType 对应时才调用入参 reducer\n * 与传统的 reducer 不一样在于 传统的 reducer 需要在内部判断 actionType，\n * 而该高阶 reducer 保证了只有当 actionType 正确对应了才执行入参 reducer，\n * 入参 reducer 可以直接对数据进行维护，免去对 actionType 的判断逻辑。\n *\n * @param {any} actionType\n * @param {any} [reducer=identify]\n * @param {any} ctx 执行 reducer 的上下文\n * @returns\n */\nfunction handleAction(actionType) {\n  var reducer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identify;\n  var ctx = arguments[2];\n\n  return function (state, action) {\n    var type = action.type;\n\n    if (type && actionType !== type) {\n      return state;\n    }\n    return reducer.call(ctx, state, action);\n  };\n}\n\n/**\n *\n *\n * @param {any} reducers\n * @returns\n */\nfunction reduceReducers() {\n  for (var _len = arguments.length, reducers = Array(_len), _key = 0; _key < _len; _key++) {\n    reducers[_key] = arguments[_key];\n  }\n\n  /**\n   *  @param {any} previous state\n   *  @param {any} current action\n   */\n  return function (previous, current) {\n    return reducers.reduce(\n    /**\n     *\n     *  @param {any} p state\n     *  @param {any} r reducer\n     */\n    function (p, r) {\n      return r(p, current);\n    }, previous);\n  };\n}\n\n/**\n * 无序链式调用 handlers 中的 reducer ，所有 reducer 维护同一个 state\n *\n * @param {{ actionType:reducer }} handlers\n * @param {any} defaultState\n * @param {any} ctx 执行  handle 的上下文\n * @returns\n */\nfunction handleActions(handlers, defaultState, ctx) {\n  var reducers = (0, _keys2.default)(handlers).map(function (type) {\n    return handleAction(type, handlers[type], ctx);\n  });\n  // 将 reducer 包装成调用链，这里有个问题：\n  // 由于这个链式调用并不保障每次 reducers 对 state 进行更新时，链内只有一个 reducer 响应 actionType。\n  // 导致的结果是如果有多个 reducer 对同一 actionType 进行响应的话，无法保证这些 reducers 之间的调用顺序。\n\n  // 更新：\n  // 这样做的目的是因为，一般对于同一个 actionType 允许有多个 reducer 进行响应，而这些 reducers 每个都负责维护不同的 state 结构，故当多个 reducer 对同一 actionType 进行响应时，reducers 的调用顺序无关紧要。\n  var reducer = reduceReducers.apply(undefined, (0, _toConsumableArray3.default)(reducers));\n  return function () {\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultState;\n    var action = arguments[1];\n    return reducer(state, action);\n  };\n}\n\nexports.default = handleActions;"]},"metadata":{},"sourceType":"script"}