import _defineProperty from 'babel-runtime/helpers/defineProperty';
import _objectWithoutProperties from 'babel-runtime/helpers/objectWithoutProperties';
import _extends from 'babel-runtime/helpers/extends';
import _Object$getPrototypeOf from 'babel-runtime/core-js/object/get-prototype-of';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';
import _inherits from 'babel-runtime/helpers/inherits';

var _dec, _dec2, _class, _class2, _temp;

//外部依赖包
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types';
import { connect } from 'react-redux';
import classnames from 'classnames';
import isString from 'lodash/isString';
import isNumber from 'lodash/isNumber';
import isPlainObject from 'lodash/isPlainObject';
//import classnames from 'classnames';
//内部依赖包
import clearDecorator from './decorator/clear';
import loader from '../loader';
import * as util from '../utils/util';
import * as logger from '../utils/logger';
import addEventListener from '../utils/dom/addEventListener';
import localizationDefault from '../i18n/default';
import ContextMenu from './components/contextmenu';
import ContextMenuView from './contextmenu';
import Loading from './loading';
import End from './end';
import NotAutoPlay from './not-autoplay';
import Controlbar from './controlbar';
import ErrorMessage from './error-message';
import Subtitle from './track/subtitle';
import Title from './title';
import Fragment from './fragment';
import { CONTROLBAR_HIDE_TIME, ASPECT_RATIO } from '../utils/const';
import { namespace as videoNamespace } from '../model/video';
import { namespace as fullscreenNamespace } from '../model/fullscreen';
import { namespace as playPauseNamespace } from '../model/play-pause';
import { namespace as controlbarNamespace } from '../model/controlbar';
import { namespace as livingNamespace } from '../model/living';
import { namespace as readyNamespace } from '../model/ready';

var View = (_dec = connect(function (state) {
  return {
    living: state[livingNamespace],
    isFull: state[fullscreenNamespace],
    playing: state[playPauseNamespace],
    //controlbar的显示与否，代表了用户是否活跃
    userActive: state[controlbarNamespace]
  };
}), _dec2 = clearDecorator([videoNamespace, readyNamespace]), _dec(_class = _dec2(_class = (_temp = _class2 = function (_React$Component) {
  _inherits(View, _React$Component);

  function View(props) {
    _classCallCheck(this, View);

    var _this = _possibleConstructorReturn(this, (View.__proto__ || _Object$getPrototypeOf(View)).call(this, props));

    _this.outSideApi = {};
    _this.state = {
      //是否准备好，准备好就可以开始处理video的属性问题，就可以开始播放了
      ready: false
    };
    _this.dispatch = _this.props.dispatch;

    _this.onDoubleClick = function (e) {
      e.stopPropagation();
      var _this$props = _this.props,
          isFull = _this$props.isFull,
          onDoubleClick = _this$props.onDoubleClick;

      var flag = true;
      if (onDoubleClick) {
        var reFlag = onDoubleClick(e);
        if (reFlag === false) {
          //如果返回的是false，则处理flag，否则正常执行。
          flag = false;
        }
      }
      if (flag) {
        _this.dispatch({
          type: videoNamespace + '/fullscreen',
          payload: !isFull
        });
      }
    };

    _this.onClick = function (e) {
      e.stopPropagation();
      var living = _this.props.living;

      if (living) {
        //直播不跟暂停播放
        return;
      }
      var _this$props2 = _this.props,
          playing = _this$props2.playing,
          onClick = _this$props2.onClick;

      var flag = true;
      if (onClick) {
        var reFlag = onClick(e);
        if (reFlag === false) {
          //如果返回的是false，则处理flag，否则正常执行。
          flag = false;
        }
      }
      //如果flag不为true，不执行下面的操作
      if (flag) {
        if (playing) {
          _this.dispatch({
            type: videoNamespace + '/pause'
          });
        } else {
          _this.dispatch({
            type: videoNamespace + '/play'
          });
        }
      }
    };

    _this.onMouseMove = function (e) {
      var _this$props3 = _this.props,
          _this$props3$controls = _this$props3.controls,
          controls = _this$props3$controls === undefined ? true : _this$props3$controls,
          playing = _this$props3.playing,
          userActive = _this$props3.userActive,
          _this$props3$controlb = _this$props3.controlbarHideTime,
          controlbarHideTime = _this$props3$controlb === undefined ? CONTROLBAR_HIDE_TIME : _this$props3$controlb;

      if (controls && playing) {
        //清理定时器，其他组件操作也可以处理当前组件的定时器，和video model中的定时器
        _this.dispatch({
          type: videoNamespace + '/controlbarClearTimeout'
        });
        _this.dispatchControlbar(false, controlbarHideTime);
        if (!userActive) {
          _this.dispatchControlbar(true);
        }
      }
    };

    _this.locale = _extends({}, localizationDefault, props.localization);
    return _this;
  }
  //这里的配置参考jw-player的api


  _createClass(View, [{
    key: 'getChildContext',
    value: function getChildContext() {
      return {
        api: this.api,
        playerConainerDOM: this.playerConainerDOM,
        localization: this.locale,
        player: this.outSideApi,
        playerDOM: ReactDOM.findDOMNode(this.refs.video),
        controlbarHideTime: this.props.controlbarHideTime || CONTROLBAR_HIDE_TIME,
        leftSelectionComponent: this.props.leftSelectionComponent,
        rightSelectionComponent: this.props.rightSelectionComponent
      };
    }
  }, {
    key: 'init',
    value: function init(callback) {
      var _this2 = this;

      var videoDOM = ReactDOM.findDOMNode(this.refs.video);
      this.videoDOM = videoDOM;

      var _props = this.props,
          _props$forceOpenHls = _props.forceOpenHls,
          forceOpenHls = _props$forceOpenHls === undefined ? false : _props$forceOpenHls,
          file = _props.file,
          videoCallback = _props.videoCallback,
          _props$preload = _props.preload,
          preload = _props$preload === undefined ? true : _props$preload,
          _props$spaceAction = _props.spaceAction,
          spaceAction = _props$spaceAction === undefined ? true : _props$spaceAction,
          _props$controlbarHide = _props.controlbarHideTime,
          controlbarHideTime = _props$controlbarHide === undefined ? CONTROLBAR_HIDE_TIME : _props$controlbarHide,
          selection = _props.selection,
          other = _objectWithoutProperties(_props, ['forceOpenHls', 'file', 'videoCallback', 'preload', 'spaceAction', 'controlbarHideTime', 'selection']);

      if (selection === true) {
        selection = {};
      }
      if (!isString(file)) {
        file = '';
      }
      file = util.urlProtocolAdapter(file);
      var hlsjs = util.shouldUseHlsjs(file, forceOpenHls);
      var flvjs = util.shouldUseFlvjs(file);
      var videoNotSupport = false;
      if (!hlsjs && !flvjs && !util.isH5VideoSupported(file)) {
        //通过后缀名判断，没有后缀名不作处理，如果不支持原生的浏览器video格式，需要提示。
        videoNotSupport = true;
      }
      loader(_extends({
        hlsjs: hlsjs,
        flvjs: flvjs,
        videoDOM: videoDOM,
        file: file,
        localization: this.locale
      }, other)).then(function (provider) {
        //首先统一清理，可能会存在上一个的播放状态。
        _this2.dispatch({
          type: videoNamespace + '/clear'
        });
        if (isPlainObject(other.controls) && other.controls.capture) {
          //屏幕截图功能需要设置crossorigin，safari和edge才不会报安全问题。
          //但是有一个缺点，播放链接响应请求头必须设置跨域。
          provider.api.setAttribute('crossorigin', 'anonymous');
        }
        _this2.api = provider.api;
        _this2.dispatch({
          type: videoNamespace + '/init',
          payload: {
            dispatch: _this2.dispatch,
            config: _extends({
              isHls: util.isM3u8File(file),
              isFlv: util.isFlvFile(file),
              videoNotSupport: videoNotSupport,
              file: file,
              selection: selection,
              preload: preload,
              controlbarHideTime: controlbarHideTime,
              localization: _this2.locale,
              spaceAction: spaceAction,
              isHistory: _this2.context.isHistory,
              setActiveItem: _this2.context.setActiveItem,
              playlist: _this2.context.playlist,
              historyDuration: _this2.context.historyDuration,
              activeItem: _this2.context.activeItem,
              reload: function reload(callback) {
                _this2.initWithEvent(function () {
                  callback && callback();
                  _this2.setState({
                    randomKey: util.randomKey()
                  });
                });
              }
            }, other),
            api: provider.api,
            hlsjsEvents: provider.hlsjsEvents,
            videoCallback: videoCallback
          },
          initOverCallback: function initOverCallback(outSideApi) {
            logger.success('Init Over:', 'initialized sucessfully,video is now playing(or can be played).');
            _this2.outSideApi = outSideApi;
            _this2.setState({
              ready: true
            });
            callback && callback();
          }
        });
      });
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.initWithEvent();
    }
  }, {
    key: 'initWithEvent',
    value: function initWithEvent() {
      if (this.palyerMousemoveEvent) {
        this.palyerMousemoveEvent.remove();
      }
      this.playerConainerDOM = ReactDOM.findDOMNode(this.refs['player-container']);
      //react jsx直接绑定事件在高德地图上mousemove失效，而下面的这种绑定方式不失效。
      this.palyerMousemoveEvent = addEventListener(this.playerConainerDOM, 'mousemove', this.onMouseMove);
      this.init();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (this.props.file !== prevProps.file) {
        this.initWithEvent();
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.palyerMousemoveEvent.remove();
    }
  }, {
    key: 'dispatchControlbar',
    value: function dispatchControlbar(payload, controlbarHideTime) {
      this.dispatch({
        type: videoNamespace + '/controlbar',
        payload: payload,
        delayTime: controlbarHideTime
      });
    }
  }, {
    key: 'getAspectratioNumber',
    value: function getAspectratioNumber(aspectratio) {
      var ratio = aspectratio.split(':');
      if (ratio.length !== 2 || isNaN(ratio[0]) || isNaN(ratio[1])) {
        logger.warn('Config error:', 'Aspectratio format is wrong,aspectratio format should be "x:y".');
        aspectratio = ASPECT_RATIO;
        ratio = aspectratio.split(':');
      }
      return {
        x: parseInt(ratio[0], 10),
        y: parseInt(ratio[1], 10)
      };
    }
  }, {
    key: 'getContainerStyle',
    value: function getContainerStyle() {
      var _props2 = this.props,
          _props2$aspectratio = _props2.aspectratio,
          aspectratio = _props2$aspectratio === undefined ? ASPECT_RATIO : _props2$aspectratio,
          isFull = _props2.isFull,
          height = _props2.height,
          width = _props2.width,
          style = _props2.style;

      var containerStyle = {};
      if (!isFull) {
        if (width) {
          containerStyle.width = width;
        }
        if (height) {
          containerStyle.height = height;
        }
        if (width && !height && this.playerConainerDOM) {
          //第二次渲染，执行在计算height之前
          width = this.playerConainerDOM.clientWidth;
        }
        if (isNumber(width) && !height) {
          //width是数字是才计算
          var ratio = this.getAspectratioNumber(aspectratio);
          containerStyle.height = width * ratio.y / ratio.x;
        }
        if (style) {
          containerStyle = _extends({}, containerStyle, style);
        }
      }
      return containerStyle;
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          ready = _state.ready,
          randomKey = _state.randomKey;
      var _props3 = this.props,
          file = _props3.file,
          autoplay = _props3.autoplay,
          muted = _props3.muted,
          _props3$controls = _props3.controls,
          controls = _props3$controls === undefined ? true : _props3$controls,
          poster = _props3.poster,
          userActive = _props3.userActive,
          _props3$tracks = _props3.tracks,
          tracks = _props3$tracks === undefined ? [] : _props3$tracks,
          className = _props3.className,
          title = _props3.title,
          playbackRates = _props3.playbackRates,
          playbackRateControls = _props3.playbackRateControls,
          logo = _props3.logo,
          loop = _props3.loop,
          _props3$contextMenu = _props3.contextMenu,
          contextMenu = _props3$contextMenu === undefined ? true : _props3$contextMenu,
          fragment = _props3.fragment,
          isLiving = _props3.isLiving,
          _props3$timeSliderSho = _props3.timeSliderShowFormat,
          timeSliderShowFormat = _props3$timeSliderSho === undefined ? 'date' : _props3$timeSliderSho,
          living = _props3.living,
          _props3$stretching = _props3.stretching,
          stretching = _props3$stretching === undefined ? 'uniform' : _props3$stretching,
          selection = _props3.selection,
          customTimeSlider = _props3.customTimeSlider,
          children = _props3.children;

      if (selection && !this.context.isHistory) {
        loop = true;
      }
      var locale = this.locale;
      var containerStyle = this.getContainerStyle();
      var videoProps = {};
      if (ready) {
        videoProps = {
          onDoubleClick: this.onDoubleClick,
          onClick: this.onClick,
          poster: poster
        };
      }
      return React.createElement(
        ContextMenu,
        {
          key: file + randomKey,
          ref: 'player-container',
          overflow: false,
          content: React.createElement(ContextMenuView, { content: contextMenu })
        },
        React.createElement(
          'div',
          {
            className: classnames('html5-player-container', className, {
              'cursor-none': !userActive
            }),
            style: containerStyle
          },
          !ready && React.createElement(
            'span',
            { className: 'html5-player-init-text' },
            locale.loadingPlayerText
          ),
          React.createElement('video', _extends({
            loop: loop,
            className: classnames('html5-player-tag', _defineProperty({
              'cursor-none': !userActive,
              'cursor-pointer': !(isLiving || living)
            }, 'html5-player-tag-stretching-' + stretching, true)),
            ref: 'video'
          }, videoProps)),
          React.createElement('div', {
            //视频保护色，纯白的需要保护色
            className: 'html5-player-pretect-bg'
          }),
          ready && React.createElement(
            'span',
            null,
            isString(logo) && React.createElement('img', {
              className: 'html5-player-logo-container',
              alt: '',
              src: logo
            }),
            React.isValidElement(logo) && React.createElement(
              'div',
              { className: 'html5-player-logo-container' },
              logo
            ),
            isPlainObject(logo) && React.createElement(
              'a',
              {
                className: 'html5-player-logo-container',
                href: logo.link || '',
                target: logo.target || '__blank'
              },
              React.createElement('img', { alt: '', src: logo.image })
            ),
            React.createElement(
              'span',
              null,
              title && React.createElement(Title, { title: title }),
              React.createElement(Loading, null),
              React.createElement(End, null),
              React.createElement(ErrorMessage, null),
              !autoplay && React.createElement(NotAutoPlay, null),
              controls && React.createElement(Controlbar, {
                tracks: tracks,
                playbackRates: playbackRates,
                playbackRateControls: playbackRateControls,
                muted: muted,
                controls: controls,
                isLiving: isLiving,
                timeSliderShowFormat: timeSliderShowFormat,
                hasFragment: !!fragment,
                customTimeSlider: customTimeSlider
              }),
              React.createElement(Subtitle, { userActive: userActive }),
              fragment && React.createElement(Fragment, { url: fragment })
            ),
            children
          )
        )
      );
    }
  }]);

  return View;
}(React.Component), _class2.propTypes = {
  //播放的文件
  file: PropTypes.string.isRequired,
  //播放开始之前要显示的海报图像的URL
  poster: PropTypes.string,
  //播放器纵横比，默认为16:9，只有设置了宽度的情况下才会生效。
  //格式为x:y
  aspectratio: PropTypes.string,
  stretching: PropTypes.string,
  /**---begin Behavior**/
  //静音
  muted: PropTypes.bool,
  //preload=true，提前加载视频，false为不提前加载视频
  //默认preload=true
  //autoplay优先与preload
  preload: PropTypes.bool,
  //自动播放
  autoplay: PropTypes.bool,
  //设置默认开始播放的时间
  defaultCurrentTime: PropTypes.number,
  //播完重复播放
  loop: PropTypes.bool,
  //是否开启space按键暂停播放功能，默认开启
  spaceAction: PropTypes.bool,
  //强制定义为直播
  isLiving: PropTypes.bool,
  showLoadingLazyTime: PropTypes.number,
  //直播最大buffer
  livingMaxBuffer: PropTypes.number,
  //自定义timeout时间
  timeout: PropTypes.number,
  //尝试重连次数
  retryTimes: PropTypes.number,
  //默认为time
  timeSliderShowFormat: PropTypes.string,
  /**---end Behavior**/
  /**---begin Appearance**/
  //多语言
  localization: PropTypes.object,
  //controlbar无操作后，多少毫秒隐藏时间
  controlbarHideTime: PropTypes.number,
  controls: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),
  fragment: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
  selection: PropTypes.oneOfType([PropTypes.bool, PropTypes.object]),
  leftSelectionComponent: PropTypes.element,
  rightSelectionComponent: PropTypes.element,
  height: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  width: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
  /**---end Appearance**/
  tracks: PropTypes.array,
  playbackRates: PropTypes.array,
  playbackRateControls: PropTypes.bool,
  logo: PropTypes.oneOfType([PropTypes.string, PropTypes.object, PropTypes.element])
}, _class2.childContextTypes = {
  api: PropTypes.object,
  playerConainerDOM: PropTypes.object,
  localization: PropTypes.object,
  //实例化后的player，可直接调用对外api，给使用者调用。
  player: PropTypes.object,
  playerDOM: PropTypes.object,
  controlbarHideTime: PropTypes.number,
  leftSelectionComponent: PropTypes.element,
  rightSelectionComponent: PropTypes.element
}, _class2.contextTypes = {
  isHistory: PropTypes.bool,
  setActiveItem: PropTypes.func,
  playlist: PropTypes.array,
  historyDuration: PropTypes.number,
  activeItem: PropTypes.number
}, _temp)) || _class) || _class);
export { View as default };