import _defineProperty from 'babel-runtime/helpers/defineProperty';
import _Object$create from 'babel-runtime/core-js/object/create';
import _extends from 'babel-runtime/helpers/extends';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import isString from 'lodash/isString';
import addEventListener from '../utils/dom/addEventListener';
import * as util from '../utils/util';
//使用的是backbone event
//外api的事件，内部数据流只使用redux
import event from '../utils/event';

/**
 * 拥有所有的video dom对象的属性和方法，
 * 同时添加或者改造了新属性和方法。
 * 添加新的自定义事件
 * 事件监控需要使用on，不使用addEventListener方式
 * @this { boolean } loading 加载中（新增属性）
 * @this { boolean } playing 播放中（新增属性）
 * @this { boolean } living 是否是直播
 * @this { number } bufferTime buffer秒数（新增属性）
 * @this { boolean } isError 是否展示错误信息，这个属性在model/vidoe中设置的
 * @this { boolean } onControlbarEnter 鼠标是否在controlbar上，这个属性在model/vidoe中设置的
 * @this { boolean } seekingState 是否在seeking，timeline点击拖动也是在seeking，这个跟原生的有点不一样。
 * @this { boolean } notAutoPlayViewHide 当autoplay为false时，这个属性false为notAutoPlay页面展示，否则隐藏
 * @this { boolean } controlbarShow true controlbar显示，false controlbar 隐藏，这个属性在model/vidoe中设置的
 * @this { number } videoGaps 断片累加值，也是记录值
 * @this { number } currentSubtitleTrack 当前选择的字幕
 * @this { boolean } reloading 是否在重载
 *    //合成录像，摄像头上传视频会中断，会分成几个视频，然后这几个视频会合并成一个视频
 *    //但是这个视频不是整个时段的，会有断的，为了给用户知道这段录像哪里断了，需要而外处理
 *    //这里是为了算出播放中，遇到断片的情况
 */

var API = function () {
  function API(videoDOM, file) {
    var _this2 = this;

    _classCallCheck(this, API);

    this.videoGaps = 0;
    this.seekingState = false;

    this.videoDOM = videoDOM;
    this.file = file;
    //绑定自定义事件处理方法
    this.event = _extends({}, event);
    var _this = this;
    try {
      var _loop = function _loop(_k) {
        if (_k === 'webkitDisplayingFullscreen' || _k === 'webkitSupportsFullscreen') {
          return 'continue';
        }
        //方法处理
        if (Object.prototype.toString.apply(videoDOM[_k]) === '[object Function]') {
          var oldKey = _k;
          if (_this[_k]) {
            //如果API中定义了该属性，则添加前缀
            _k = '_' + _k;
          }
          _this2[_k] = function () {
            videoDOM[oldKey].apply(videoDOM, arguments);
          };
        } else {
          //属性处理
          if (_this[_k]) {
            //如果API中定义了该属性，则添加前缀
            _k = '_' + _k;
          }
          _this = _Object$create(_this, _defineProperty({}, _k, {
            get: function get() {
              return videoDOM[_k];
            },
            set: function set(val) {
              videoDOM[_k] = val;
            }
          }));
          //自定义新属性
          switch (_k) {
            case 'paused':
              _this = _Object$create(_this, {
                playing: {
                  get: function get() {
                    return !videoDOM[_k];
                  },
                  set: function set(val) {
                    videoDOM[_k] = !val;
                  }
                }
              });
              break;
            case 'buffered':
              _this = _Object$create(_this, {
                bufferTime: {
                  // eslint-disable-next-line
                  get: function get() {
                    return _this.getBufferTime();
                  }
                }
              });
              break;
            case 'duration':
              _this = _Object$create(_this, {
                duration: {
                  // eslint-disable-next-line
                  get: function get() {
                    return _this.fragmentDuration || videoDOM.duration;
                  }
                }
              });
              break;
            default:
          }
        }
        k = _k;
      };

      //这里把vidoeDOM里面的的大部分属性和方法，都绑在了this中。
      for (var k in videoDOM) {
        var _ret = _loop(k);

        if (_ret === 'continue') continue;
      }
    } catch (e) {
      //nothing
    }
    return _this;
  }
  //默认值


  _createClass(API, [{
    key: 'play',

    //载入视频源，这里不可以用箭头函数
    value: function play() {
      if (!this.playing) {
        this._play();
      }
    }
  }, {
    key: 'pause',
    value: function pause() {
      if (this.playing) {
        this._pause();
      }
    }
  }, {
    key: 'setVolume',
    value: function setVolume(volume) {
      if (!this.muted) {
        this.volume = volume;
      }
    }
    //获取buffer的秒数

  }, {
    key: 'getBufferTime',
    value: function getBufferTime() {
      if (this.living) {
        if (this.buffered.length > 0) {
          return this.buffered.end(0);
        } else {
          return 0;
        }
      }
      var buf = this.buffered;
      var total = 0;
      for (var ii = 0; ii < buf.length; ii++) {
        total += buf.end(ii) - buf.start(ii);
      }
      return total;
    }
    //重置api一些值

  }, {
    key: 'reset',
    value: function reset() {
      this.videoGaps = 0;
    }
    /**
     * 监控事件
     * @param { string } type 事件类型
     * @param { function } callback 回调函数
     */

  }, {
    key: 'on',
    value: function on(dom, type, callback) {
      var _this3 = this;

      if (isString(dom)) {
        callback = type;
        type = dom;
        dom = this;
      }
      //自定义事件和dom事件一起绑定了，这里不做判断有没有type类型的dom事件
      var event = addEventListener(dom, type, callback);
      //自定义事件
      this.event.on(type, callback);
      //remove适配
      var eventListIndex = util.randomKey();
      if (!this.eventList) {
        this.eventList = {};
      }
      if (!this.eventList[type]) {
        this.eventList[type] = {};
      }
      this.eventList[type][eventListIndex] = event;
      //这个remove是给当前事件解绑使用
      var returnRemove = function returnRemove() {
        _this3.eventList[type][eventListIndex] && _this3.eventList[type][eventListIndex].remove();
        //删除移除指定的this.eventList[type]
        delete _this3.eventList[type][eventListIndex];
        //移除当前自定义事件
        _this3.event.off(type, callback);
      };
      //返回的事件对像只能移除当前监听的事件。
      return {
        off: returnRemove
      };
    }
    /**
     * 移除指定或者全部监控事件，包括多次绑定的事件
     * @param { string || undefined || array } type 事件类型
     */

  }, {
    key: 'off',
    value: function off(type) {
      var _this4 = this;

      if (type === undefined) {
        //移除全部事件
        for (var _k2 in this.eventList) {
          for (var j in this.eventList[_k2]) {
            this.eventList[_k2][j].remove();
          }
        }
        this.eventList = {};
        //移除全部自定义事件
        this.event.off();
      } else if (Object.prototype.toString.apply(type) === '[object Array]') {
        //移除部分事件
        type.forEach(function (v) {
          for (var _j in _this4.eventList[v]) {
            _this4.eventList[v][_j].remove();
          }
          delete _this4.eventList[v];
        });
      } else {
        //移除一个事件
        for (var _j2 in this.eventList[type]) {
          this.eventList[type][_j2].remove();
        }
        delete this.eventList[type];
        //移除自定义事件
        this.event.off(type);
      }
    }
    //触发自定义事件

  }, {
    key: 'trigger',
    value: function trigger(name) {
      var _event;

      for (var _len = arguments.length, params = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        params[_key - 1] = arguments[_key];
      }

      return (_event = this.event).trigger.apply(_event, [name].concat(params));
    }
  }]);

  return API;
}();

export { API as default };