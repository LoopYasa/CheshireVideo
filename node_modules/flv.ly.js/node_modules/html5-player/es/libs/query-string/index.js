import _extends from 'babel-runtime/helpers/extends';
import _slicedToArray from 'babel-runtime/helpers/slicedToArray';
import _getIterator from 'babel-runtime/core-js/get-iterator';
import _Object$create from 'babel-runtime/core-js/object/create';
import _Object$assign from 'babel-runtime/core-js/object/assign';
import _Object$keys from 'babel-runtime/core-js/object/keys';
import _typeof from 'babel-runtime/helpers/typeof';
import decodeComponent from './decode-uri-component';

var strictUriEncode = function strictUriEncode(str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, function (x) {
    return '%' + x.charCodeAt(0).toString(16).toUpperCase();
  });
};

export function randomKey() {
  return Math.random().toString(36).substring(7).split('').join('');
}

function encoderForArrayFormat(options) {
  switch (options.arrayFormat) {
    case 'index':
      return function (key, value, index) {
        return value === null ? [encode(key, options), '[', index, ']'].join('') : [encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('');
      };
    case 'bracket':
      return function (key, value) {
        return value === null ? [encode(key, options), '[]'].join('') : [encode(key, options), '[]=', encode(value, options)].join('');
      };
    default:
      return function (key, value) {
        return value === null ? encode(key, options) : [encode(key, options), '=', encode(value, options)].join('');
      };
  }
}

function parserForArrayFormat(options) {
  var result = void 0;

  switch (options.arrayFormat) {
    case 'index':
      return function (key, value, accumulator) {
        result = /\[(\d*)\]$/.exec(key);

        key = key.replace(/\[\d*\]$/, '');

        if (!result) {
          accumulator[key] = value;
          return;
        }

        if (accumulator[key] === undefined) {
          accumulator[key] = {};
        }

        accumulator[key][result[1]] = value;
      };
    case 'bracket':
      return function (key, value, accumulator) {
        result = /(\[\])$/.exec(key);
        key = key.replace(/\[\]$/, '');

        if (!result) {
          accumulator[key] = value;
          return;
        }

        if (accumulator[key] === undefined) {
          accumulator[key] = [value];
          return;
        }

        accumulator[key] = [].concat(accumulator[key], value);
      };
    default:
      return function (key, value, accumulator) {
        if (accumulator[key] === undefined) {
          accumulator[key] = value;
          return;
        }

        accumulator[key] = [].concat(accumulator[key], value);
      };
  }
}

function encode(value, options) {
  if (options.encode) {
    return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
  }

  return value;
}

function decode(value, options) {
  if (options.decode) {
    return decodeComponent(value);
  }

  return value;
}

function keysSorter(input) {
  if (Array.isArray(input)) {
    return input.sort();
  }

  if ((typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object') {
    return keysSorter(_Object$keys(input)).sort(function (a, b) {
      return Number(a) - Number(b);
    }).map(function (key) {
      return input[key];
    });
  }

  return input;
}

export function extract(input) {
  var queryStart = input.indexOf('?');
  if (queryStart === -1) {
    return '';
  }
  return input.slice(queryStart + 1);
}

export function parse(input, options) {
  options = _Object$assign({ decode: true, arrayFormat: 'none' }, options);

  var formatter = parserForArrayFormat(options);

  // Create an object with no prototype
  var ret = _Object$create(null);

  if (typeof input !== 'string') {
    return ret;
  }

  input = input.trim().replace(/^[?#&]/, '');

  if (!input) {
    return ret;
  }

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _getIterator(input.split('&')), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var param = _step.value;

      var _param$replace$split = param.replace(/\+/g, ' ').split('='),
          _param$replace$split2 = _slicedToArray(_param$replace$split, 2),
          key = _param$replace$split2[0],
          value = _param$replace$split2[1];

      // Missing `=` should be `null`:
      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters


      value = value === undefined ? null : decode(value, options);

      formatter(decode(key, options), value, ret);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return _Object$keys(ret).sort().reduce(function (result, key) {
    var value = ret[key];
    if (Boolean(value) && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && !Array.isArray(value)) {
      // Sort object keys, not values
      result[key] = keysSorter(value);
    } else {
      result[key] = value;
    }

    return result;
  }, _Object$create(null));
}

export var stringify = function stringify(obj, options) {
  var defaults = {
    encode: true,
    strict: true,
    arrayFormat: 'none'
  };

  options = _Object$assign(defaults, options);

  if (options.sort === false) {
    options.sort = function () {};
  }

  var formatter = encoderForArrayFormat(options);

  return obj ? _Object$keys(obj).sort(options.sort).map(function (key) {
    var value = obj[key];

    if (value === undefined) {
      return '';
    }

    if (value === null) {
      return encode(key, options);
    }

    if (Array.isArray(value)) {
      var result = [];

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = _getIterator(value.slice()), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var value2 = _step2.value;

          if (value2 === undefined) {
            continue;
          }

          result.push(formatter(key, value2, result.length));
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return result.join('&');
    }

    return encode(key, options) + '=' + encode(value, options);
  }).filter(function (x) {
    return x.length > 0;
  }).join('&') : '';
};

export var parseUrl = function parseUrl(originalUrl, options) {
  var baseUrl = void 0,
      hash = '',
      urlWithoutHash = void 0,
      queryStr = '';
  if (!!~originalUrl.indexOf('#')) {
    var splitUrl = originalUrl.split('#');
    urlWithoutHash = splitUrl[0];
    hash = splitUrl[1];
  } else {
    urlWithoutHash = originalUrl;
  }
  if (!!~urlWithoutHash.indexOf('?')) {
    var _splitUrl = originalUrl.split('?');
    baseUrl = _splitUrl[0];
    queryStr = _splitUrl[1];
  } else {
    baseUrl = urlWithoutHash;
  }
  return {
    baseUrl: baseUrl,
    query: parse(queryStr, options),
    hash: hash
  };
};

/**
 * params json对象(一级)拼接url ?后面的参数
 * @param  {string} url  需要拼接的url
 * @param  {objct}  newQueryParams 需要拼接的url json参数
 * @param  {object} options 同stringify的options参数 ，
 *                          其中新增useRandomKey为true可以防止缓存问题，默认开启
 * @return {string} 拼接的url
 */
export function joinUrlParams(url) {
  var newQueryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var options = arguments[2];

  options = _extends({
    useRandomKey: true
  }, options);
  var reUrl = void 0,
      newQueryStr = void 0;
  var parseUrlObj = parseUrl(url);
  var baseUrl = parseUrlObj.baseUrl;
  var oldQueryParams = parseUrlObj.query;
  var hash = parseUrlObj.hash;
  var randomParam = {};
  if (options.useRandomKey) {
    randomParam = {
      random: randomKey()
    };
  }
  newQueryStr = stringify(_extends({}, oldQueryParams, newQueryParams, randomParam), options);
  reUrl = baseUrl + '?' + newQueryStr + '#' + hash;
  if (newQueryStr) {
    reUrl = baseUrl + '?' + newQueryStr;
  }
  if (hash) {
    reUrl += '#' + hash;
  }
  return reUrl;
}