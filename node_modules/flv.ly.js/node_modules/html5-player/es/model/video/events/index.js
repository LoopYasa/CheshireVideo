import _extends from 'babel-runtime/helpers/extends';
import _classCallCheck from 'babel-runtime/helpers/classCallCheck';
import _createClass from 'babel-runtime/helpers/createClass';
import { namespace as readyNamespace } from '../../ready';
import { namespace as videoNamespace } from '../../video';
import { HAVE_CURRENT_DATA, HAVE_FUTURE_DATA, HAVE_ENOUGH_DATA, VIDEO_TIMEOUT, LIVING_MAXBUFFER_TIME, RETRY_TIMES } from '../../../utils/const';
import * as logger from '../../../utils/logger';
import { isSafari } from '../../../utils/browser';

import { TIMEOUT_ERROR } from '../../../utils/error-code';
import { isIE } from '../../../utils/browser';
import contains from '../../../utils/dom/contains';

var Events = function () {
  function Events(payload, isFirstRun, _state) {
    _classCallCheck(this, Events);

    this.api = payload.api;
    this._state = _state;
    this.dispatch = payload.dispatch;
    //是否是第一次运行
    this.isFirstRun = isFirstRun;
    this.config = payload.config;
    if (!this.api.hlsObj) {
      this.setOriginHlsSubtitle();
    }
    this.loadeddata();
    this.timeupdate();
    this.pause();
    this.error();
    this.ended();
    this.onSpaceAndVieoFocusEvent();
    this.setTimeoutInterval();
    logger.info('Listening:', 'listening on h5 video events.');
  }

  _createClass(Events, [{
    key: 'setTimeoutInterval',
    value: function setTimeoutInterval() {
      var _this = this;

      clearInterval(this.timeoutInterval);
      var _config$timeout = this.config.timeout,
          timeout = _config$timeout === undefined ? VIDEO_TIMEOUT : _config$timeout;

      this.timeoutInterval = setInterval(function () {
        //定时查看是否超时
        if (_this.api.playing) {
          _this.timeoutAction();
        }
      }, timeout);
    }
  }, {
    key: 'reset',
    value: function reset() {
      this.currentTime = 0;
      clearInterval(this.timeoutInterval);
    }
    //原生浏览器hls

  }, {
    key: 'setOriginHlsSubtitle',
    value: function setOriginHlsSubtitle() {
      var _this2 = this;

      var api = this.api;
      if (this.config.isHls) {
        var textTracks = api.textTracks;
        var clearIntervalObj = void 0;
        clearInterval(clearIntervalObj);
        var tempLength = 0;
        //trackList长度一样后执行次数
        var count = 0;
        clearIntervalObj = setInterval(function () {
          //由于firefox不支持change事件
          if (textTracks.length === 0) {
            return;
          }
          var subtitleLength = 0;
          var subtitleList = [];
          var subtitleId = 0;
          for (var i = 0; i < textTracks.length; i++) {
            if (textTracks[i].kind === 'subtitles') {
              subtitleList.push(_extends({
                id: subtitleId,
                name: textTracks[i].label
              }, textTracks[i]));
              subtitleId++;
              textTracks[i].mode = 'disabled';
              subtitleLength++;
            }
          }
          if (tempLength === subtitleLength) {
            if (count >= 2) {
              //如果两次以上length都没变化就判断为textTrack没变化。
              //这里不排除网络很差的导致加载出问题，但是这种极端情况，不好处理，也没必要处理。
              //因为如果网络都差到连2KB左右的内容都加载不了，也完全播放不了视频了。
              api.off('cuechange'); //防止连续监听事件。
              for (var _i = 0; _i < textTracks.length; _i++) {
                api.on(textTracks[_i], 'cuechange', function (cues) {
                  _this2.dispatch({
                    type: videoNamespace + '/hlsSubtitleCues',
                    payload: cues.target.activeCues
                  });
                });
              }
              _this2.dispatch({
                type: videoNamespace + '/subtitleList',
                payload: {
                  subtitleList: subtitleList,
                  subtitleId: -1
                }
              });
              clearInterval(clearIntervalObj);
            }
            count++;
          }
          tempLength = subtitleLength;
        }, 200);
      }
    }
  }, {
    key: 'loadeddata',
    value: function loadeddata() {
      var _this3 = this;

      var api = this.api;
      var dispatch = this.dispatch;
      var _config = this.config,
          isLiving = _config.isLiving,
          defaultCurrentTime = _config.defaultCurrentTime;

      api.on('loadeddata', function () {
        _this3.isLoadeddata = true;
        //视频载入后重新定时处理超时。
        _this3.setTimeoutInterval();
        //设置重载状态false，这个视事件运行了，视频就可以播放了。
        logger.info('Ready:', 'video is ready to played.');
        api.trigger('ready');
        if (defaultCurrentTime !== undefined) {
          // console.log(window.historyVideoCurrentTime);
          api.currentTime = window.historyVideoCurrentTime || defaultCurrentTime;
          //重置
          window.historyVideoCurrentTime = 0;
        }
        if (!_this3.isFirstRun) {
          dispatch({
            type: videoNamespace + '/play'
          });
        } else if (api.autoplay) {
          dispatch({
            type: videoNamespace + '/play'
          });
        }
        dispatch({
          type: readyNamespace + '/state'
        });
        //兼容edge，用来比较获取loading状态
        _this3.currentTime = api.currentTime;
        //currentTime处理
        dispatch({
          type: videoNamespace + '/time',
          payload: {
            currentTime: api.currentTime,
            duration: api.duration
          }
        });
        dispatch({
          type: videoNamespace + '/living',
          payload: {
            duration: isLiving ? Infinity : api.duration
          }
        });
        dispatch({
          type: videoNamespace + '/loading',
          payload: false
        });
        api.reloading = false;
      });
    }
  }, {
    key: 'timeoutAction',
    value: function timeoutAction() {
      var api = this.api;
      var dispatch = this.dispatch;
      var locale = api.localization;
      var _config$retryTimes = this.config.retryTimes,
          retryTimes = _config$retryTimes === undefined ? RETRY_TIMES : _config$retryTimes;
      // console.log(type, 'this._state.retryReloadTime', this._state.retryReloadTime);
      //处理超时
      // console.log(this.currentTime, api.currentTime, api.playing);

      if (this.api.isError || this.api.ended) {
        return;
      }
      if (this.currentTime !== api.currentTime && this.currentTime !== undefined) {
        //视频在播放（视频状态为播放中，但是没有因为网络而卡顿），不处理
        return;
      }
      //超时最多尝试重载retryTimes，如果没有载入过视频，不做重连
      var isLiving = api.living || this.config.isLiving;
      if (this._state.retryReloadTime < retryTimes && isLiving && this.isLoadeddata) {
        //直播才做重载
        this._state.retryReloadTime++;
        // console.log(this.retryReloadTime);
        logger.info('Timeout:', 'try to reload.');
        dispatch({
          type: videoNamespace + '/reload'
        });
      } else {
        if (isLiving && this.isLoadeddata) {
          logger.error('Timeout:', 'try to reload ' + retryTimes + ' times but video can not be loaded.');
        }
        if (!api.isError) {
          api.trigger('error', {
            //基本上trigger都是为了对外提供api，error是个比较特殊的情况，寄对外提供了事件，也对内提供了事件。
            //如果只是对内不对外的话，不可以使用trigger处理事件，所有的都用redux。
            data: {},
            message: locale.timeout,
            type: TIMEOUT_ERROR
          });
        }
        this._state.retryReloadTime = 0;
      }
    }
  }, {
    key: 'timeupdate',
    value: function timeupdate() {
      var _this4 = this;

      var api = this.api;
      var dispatch = this.dispatch;
      var _config2 = this.config,
          _config2$livingMaxBuf = _config2.livingMaxBuffer,
          livingMaxBuffer = _config2$livingMaxBuf === undefined ? LIVING_MAXBUFFER_TIME : _config2$livingMaxBuf,
          isHls = _config2.isHls;

      api.on('timeupdate', function () {
        _this4.setTimeoutInterval();
        if (api.playing) {
          if (!api.living) {
            //直播不播放状态中不处理loading
            //begin----处理loading状态
            //isIE包括了Edge
            if (_this4.currentTime === api.currentTime && isIE()) {
              if (!api.loading) {
                //需要做判断，要不会被clearTimeout了
                dispatch({
                  type: videoNamespace + '/loading',
                  payload: true
                });
              }
            } else if (!api.loading && api.readyState === HAVE_CURRENT_DATA && !api.ended
            //api.eneded解决firefox，结束后readyState=2导致的loading未关闭的问题
            ) {
                if (!api.loading) {
                  dispatch({
                    type: videoNamespace + '/loading',
                    payload: true
                  });
                }
              } else if (api.loading && (api.readyState === HAVE_FUTURE_DATA || api.readyState === HAVE_ENOUGH_DATA)) {
              dispatch({
                type: videoNamespace + '/loading',
                payload: false
              });
            }
            //end----处理loading状态
          } else if (api.loading && _this4.currentTime !== api.currentTime) {
            //直播状态正在播放中如果发现loading，直接隐藏。
            dispatch({
              type: videoNamespace + '/loading',
              payload: false
            });
          }
          //currentTime处理
          if (!api.seekingState) {
            dispatch({
              type: videoNamespace + '/time',
              payload: {
                currentTime: api.ended ? api.duration : api.currentTime,
                duration: api.duration
              }
            });
          }
          //直播延时变大处理
          //safari原生的hls，在直播延时处理失效，还没有解决办法，不过hls本来的延时就大，影响不大。
          //使用的hls.js和flv.js延时处理是正常的。
          //edge原生的hls的也正常，不过经常会卡，然后就触发了重载，然后就正常了。
          //正常网络下hls处理延时变大会很少的，flv才可能频繁一点，flv的实时性要求高。
          if (api.living && api.buffered.length > 0 && api.currentTime && livingMaxBuffer > 0 && !api.isError) {
            //livingMaxBuffer=0，相当于没设置，最好不要设置为0
            if (isHls) {
              //hls需要的直播需要特殊对待。
              livingMaxBuffer += 15;
            }
            //直播实时处理，让视频接近实时。
            // console.log(api.bufferTime, api.buffered.end(0));
            if (api.bufferTime - api.currentTime > livingMaxBuffer) {
              var reduceBuffer = void 0;
              if (isHls) {
                reduceBuffer = 15;
              } else {
                reduceBuffer = 1;
              }
              //浏览器原生的hls，在直播状态设置currentTime失效。
              api.currentTime = api.bufferTime - reduceBuffer;
              //标记正在减少延时状态
              _this4.reducingDelay = true;
              //同时超时重新计算
              logger.log('Delay Reduce', 'Due to the high delay, there is a need to reduce the delay.');
            }
          }
          if (api.currentTime) {
            //只要在播放，retryReloadTime就要设置为0。
            _this4._state.retryReloadTime = 0;
          }
          //最后赋值，可以用来判断视频视频卡顿
          _this4.currentTime = api.currentTime;
        }
      });
    }
  }, {
    key: 'pause',
    value: function pause() {
      var api = this.api;
      api.on('pause', function (e) {
        //清理timeupdate中的定时器。
      });
    }
  }, {
    key: 'error',
    value: function error() {
      var _this5 = this;

      var api = this.api;
      var dispatch = this.dispatch;
      var locale = api.localization;
      api.on('error', function (data) {
        _this5.reset();
        //有message和type的是hls.js等事件的错误
        api.isError = true;
        var message = data.message;
        if (!message) {
          logger.error('H5 Video Error:', 'original h5 video error');
        }
        if (!message) {
          message = locale.fileCouldNotPlay;
        }
        if (_this5.config.videoNotSupport) {
          message = locale.videoNotSupport;
        }
        dispatch({
          type: videoNamespace + '/errorMessage',
          payload: {
            message: message
          }
        });
      });
    }
  }, {
    key: 'ended',
    value: function ended() {
      var _this6 = this;

      var api = this.api;
      var dispatch = this.dispatch;
      api.on('ended', function () {
        logger.info('Ended:', 'video is ended');
        if (!api.living && !_this6.config.isLiving) {
          //直播是不会结束的
          //即使监控到end事件也不做处理
          dispatch({
            type: videoNamespace + '/end',
            payload: true
          });
        } else if (!isSafari()) {
          //直播有时候会遇到结束事件，那是因为转发切换触发结束事件
          //safari flv.js直播经常报ended事件。
          //等待两秒重新拉流，因为转发切换可能会有延时，播放链接不是立即就可以播放。
          //真正直播结束的场景，目前不做考虑。
          setTimeout(function () {
            dispatch({
              type: videoNamespace + '/reload'
            });
          }, 2000);
        }
      });
    }
    //键盘空格键和video聚焦事件

  }, {
    key: 'onSpaceAndVieoFocusEvent',
    value: function onSpaceAndVieoFocusEvent() {
      var _this7 = this;

      if (!this.config.spaceAction) {
        return false;
      }
      var api = this.api;
      var dispatch = this.dispatch;
      var keydown = function keydown() {
        _this7.playerKeydownEvent && _this7.playerKeydownEvent.off();
        _this7.playerKeydownEvent = api.on(api.ownerDocument, 'keydown', function (e) {
          if (api.living) {
            return;
          }
          if (e.keyCode === 32) {
            logger.info('Keydown:', 'space key is pressed');
            if (api.playing) {
              dispatch({
                type: videoNamespace + '/pause'
              });
            } else {
              dispatch({
                type: videoNamespace + '/play'
              });
            }
          }
        });
      };
      api.on(api.parentNode, 'mouseenter', function (e) {
        api.trigger('focus', true);
        if (!api.focus) {
          logger.info('Video Focus:', 'video is focused');
        }
        api.focus = true;
        keydown();
      });
      api.on(api.parentNode, 'mouseleave', function (e) {
        //为点击播放器，移出去播放器，算失去聚焦。
        if (!_this7.mousedown) {
          api.focus = false;
          api.trigger('focus', false);
          logger.info('Video Unfocused:', 'video is unfocused');
          _this7.playerKeydownEvent && _this7.playerKeydownEvent.off();
        }
      });
      api.on(api.parentNode, 'mousedown', function (e) {
        _this7.mousedown = true;
        if (!api.focus) {
          api.trigger('focus', true);
          logger.info('Video Focus:', 'video is focused');
        }
        _this7.documentMousedownEvent && _this7.documentMousedownEvent.off();
        _this7.documentMousedownEvent = api.on(api.ownerDocument, 'mousedown', function (e) {
          if (!contains(api.parentNode, e.target)) {
            _this7.mousedown = false;
            api.trigger('focus', false);
            logger.info('Video Unfocused:', 'video is unfocused');
            _this7.documentMousedownEvent.off();
            _this7.playerKeydownEvent.off();
          }
        });
        keydown();
      });
    }
  }]);

  return Events;
}();

export default function () {
  for (var _len = arguments.length, params = Array(_len), _key = 0; _key < _len; _key++) {
    params[_key] = arguments[_key];
  }

  return new (Function.prototype.bind.apply(Events, [null].concat(params)))();
}